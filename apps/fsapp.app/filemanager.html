<html>

  <head>
    <link rel="stylesheet" href="filemanager.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="/apps/libfileview.app/fileHandler.js"></script>
    <script src="/assets/libs/filer.min.js"></script>
    <!-- in any sane case this wouldn't be required. This isn't a sane case, Buffer doesn't work without importing this -->
    <script src="jszip.js"></script>
  </head>

  <body>
    <div class="container">
      <div class="sidebar">
        <button><i class="fa-solid fa-clock-rotate-left fa-lg"></i>Recent</button>
        <hr>
        </hr>
        <button><i class="fa-solid fa-laptop fa-lg"></i>My files</button>
      </div>
      <div class="fileView">
        <div class="topbar">
          <div class="breadcrumbs"><button>My files</button><span>></span><button>owo :3</button></div>
          <div class="sep"></div>
          <button><i class="fa-solid fa-magnifying-glass fa-lg"></i></button>
          <button><i class="fa-solid fa-table-cells-large fa-lg"></i></button>
          <button><i class="fa-solid fa-arrow-up-a-z fa-lg"></i>
            <!--<i class="fa-solid fa-arrow-down-z-a fa-lg"></i> - opposite-->
          </button>
          <button><i class="fa-solid fa-ellipsis-vertical fa-lg"></i></button>
        </div>
        <hr>
        <table>
          <thead>
            <tr>
              <th data-type="icon">Icon<span class="resize-handle hidden-resize-handle"></span></th>
              <th data-type="name">Name<span class="resize-handle"></span></th>
              <th data-type="size">Size<span class="resize-handle"></span></th>
              <th data-type="type">Type<span class="resize-handle"></span></th>
              <th data-type="modified">Date modified<span class="resize-handle"></span></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><i class="fa-brands fa-rust"></i></td>
              <td>nya.rs</td>
              <td>1 MB</td>
              <td>Rust source code</td>
              <td>Today 17:00</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <script>
      // implementing it myself was too hard so i just stole it from https://codepen.io/adam-lynch/pen/GaqgXP


      const newcontextmenu = new anura.ContextMenu()
      newcontextmenu.addItem("Get Info", function() {})
      newcontextmenu.addItem("Pin to Shelf", function() {})
      newcontextmenu.addItem("Refresh", function() {
        reload()
      })
      newcontextmenu.addItem("Cut", function() {
        cut()
      })
      newcontextmenu.addItem("Copy", function() {
        copy()
      })
      newcontextmenu.addItem("Paste", function() {
        paste()
      })
      newcontextmenu.addItem("Delete", function() {
        deleteFile()
      })
      newcontextmenu.addItem("Rename", function() {
        rename()
      })
      newcontextmenu.addItem("Upload from PC", function() {
        upload()
      })
      newcontextmenu.addItem("New folder", function() {
        newFolder()
      })


      const min = 150;
      // The max (fr) values for grid-template-columns
      const columnTypeToRatioMap = {
        'icon': 0.1,
        'name': 3,
        'size': 1,
        'type': 1,
        'modified': 1
      };

      const table = document.querySelector('table');
      /*
      The following will soon be filled with column objects containing
      the header element and their size value for grid-template-columns
      */
      const columns = [];
      let headerBeingResized;

      // The next three functions are mouse event callbacks

      // Where the magic happens. I.e. when they're actually resizing
      const onMouseMove = (e) => requestAnimationFrame(() => {
        console.log('onMouseMove');

        (window.getSelection ? window.getSelection() : document.selection).empty()

        // Calculate the desired width
        horizontalScrollOffset = document.documentElement.scrollLeft;
        const width = (horizontalScrollOffset + e.clientX) - headerBeingResized.offsetLeft;

        // Update the column object with the new size value
        const column = columns.find(({
          header
        }) => header === headerBeingResized);
        column.size = Math.max(min, width) + 'px'; // Enforce our minimum

        // For the other headers which don't have a set width, fix it to their computed width
        columns.forEach((column) => {
          if (column.size.startsWith('minmax')) { // isn't fixed yet (it would be a pixel value otherwise)
            column.size = parseInt(column.header.clientWidth, 10) + 'px';
          }
        });

        /*
            Update the column sizes
            Reminder: grid-template-columns sets the width for all columns in one value
        */
        table.style.gridTemplateColumns = columns
          .map(({
            header,
            size
          }) => size)
          .join(' ');
      });

      // Clean up event listeners, classes, etc.
      const onMouseUp = () => {
        console.log('onMouseUp');

        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
        headerBeingResized.classList.remove('header--being-resized');
        headerBeingResized = null;
      };

      // Get ready, they're about to resize
      const initResize = ({
        target
      }) => {
        console.log('initResize');

        headerBeingResized = target.parentNode;
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        headerBeingResized.classList.add('header--being-resized');
      };

      // Let's populate that columns array and add listeners to the resize handles
      document.querySelectorAll('th').forEach((header) => {
        const max = columnTypeToRatioMap[header.dataset.type] + 'fr';
        columns.push({
          header,
          // The initial size value for grid-template-columns:
          size: `minmax(${min}px, ${max})`,
        });
        header.querySelector('.resize-handle').addEventListener('mousedown', initResize);
      });
    </script>
    <script>
      var currentlySelected = [];
      var clipboard = []
      var removeAfterPaste = false

      window.fs = parent.anura.fs
      window.Buffer = Filer.Buffer
      let sh = new fs.Shell()

      function loadPath(path) {
        console.debug("loading path: ", path);
        fs.readdir(path, (err, files) => {
          if (err) throw err;
          setBreadcrumbs(path);
          let table = document.querySelector("tbody");
          table.innerHTML = ''
          files.forEach(file => {
            let row = document.createElement('tr')
            let iconContainer = document.createElement('td')
            let icon = document.createElement('i')
            let name = document.createElement('td')
            let size = document.createElement('td')
            let description = document.createElement('td')
            let date = document.createElement('td')
            let type = document.createElement('td')
            fs.stat(`${path}/${file}`, function(err, stats) {
              if (err) throw err;
              if (stats.isDirectory()) {
                name.innerText = `${file}/`
                description.innerText = "Folder"
                date.innerText = new Date(stats.mtime).toLocaleString()
                icon.class = '';
                size.innerText = stats.size

                iconContainer.appendChild(icon)
                row.appendChild(iconContainer)
                row.appendChild(name)
                row.appendChild(size)
                row.appendChild(description)
                row.appendChild(date)

                row.setAttribute("data-type", 'dir');
                row.setAttribute("data-path", `${path}/${file}`);
              } else {
                name.innerText = `${file}`
                description.innerText = "Anura File"
                icon.class = '';
                date.innerText = new Date(stats.mtime).toLocaleString()
                size.innerText = stats.size

                iconContainer.appendChild(icon)
                row.appendChild(iconContainer)
                row.appendChild(name)
                row.appendChild(size)
                row.appendChild(description)
                row.appendChild(date)

                row.setAttribute("data-type", 'file');
                row.setAttribute("data-path", `${path}/${file}`);
              }
              console.debug("appending");
              table.appendChild(row)
              if (files[files.length - 1] === file) {
                reloadListeners();
              }
            });
          });
        });
      }

      function reloadListeners() {
        console.debug("reloading listeners");
        console.debug(document.querySelectorAll('tr'));
        document.querySelectorAll('tr').forEach((row) => {
          if (row.parentNode.nodeName.toLowerCase() !== "thead") {
            console.debug("adding listeners to ", row);
            row.addEventListener("mouseenter", (e) => {
              e.currentTarget.classList.add("hover");
            });
            row.addEventListener("mouseleave", (e) => {
              e.currentTarget.classList.remove("hover");
            });
            row.addEventListener("click", (e) => {
              if (currentlySelected.includes(e.currentTarget)) {
                fileAction(currentlySelected);
                currentlySelected.forEach((row) => {
                  row.classList.remove("selected")
                });
                currentlySelected = [];
                return;
              }
              if (!e.shiftKey) {
                if (!e.ctrlKey) {
                  currentlySelected.forEach((row) => {
                    row.classList.remove("selected")
                  });
                  currentlySelected = [];
                }
                e.currentTarget.classList.add("selected");
                currentlySelected.push(e.currentTarget);
              } else {
                if (currentlySelected.length == 0) {
                  e.currentTarget.classList.add("selected");
                  currentlySelected.push(e.currentTarget);
                } else {
                  var arr = Array.from(document.querySelectorAll('tr')).filter(row => row.parentNode.nodeName.toLowerCase() !== "thead")
                  var firstI = arr.indexOf(currentlySelected[currentlySelected.length - 1])
                  var lastI = arr.indexOf(e.currentTarget)
                  var first = Math.min(firstI, lastI);
                  var last = Math.max(firstI, lastI);
                  for (var i = first; i <= last; i++) {
                    if (!currentlySelected.includes(arr[i])) {
                      currentlySelected.push(arr[i]);
                      arr[i].classList.add("selected");
                    }
                  }
                }
              }
            });
          }
        });
      }

      async function fileAction(selected) {
        if (selected.length == 1) {
          // SINGLE FILE SELECTION //

          var fileSelected = selected[0];
          if (fileSelected.getAttribute("data-type") == "file") {
            console.debug("Clicked on file");
            if (fileSelected.getAttribute("data-path").split('.').slice('-1')[0] == "zip") {
              console.debug("Zip file detected, extracting")
              const path = fileSelected.getAttribute("data-path").split('.').slice(0, -1).join('.')
              await fs.mkdir(path)
              const inputFile = await fs.readFile(fileSelected.getAttribute("data-path"), async function(err, data) {
                console.log(data)
                let zip = await JSZip.loadAsync(new Blob([data], {
                  type: "application/zip"
                })) // 1) read the Blob

                console.log(zip)
                zip.forEach(async function(relativePath, zipEntry) { // 2) print entries
                    if (zipEntry.dir) {
                      fs.mkdir(`${path}/${zipEntry.name}`)
                    } else {
                      console.log(zipEntry)
                      console.log(await zipEntry.async("arraybuffer"))
                      fs.writeFile(`${path}/${zipEntry.name}`, Buffer.from(await zipEntry.async("arraybuffer")))
                    }
                  },
                  function(e) {
                    console.error(e)
                  })
                reload()
              })

            } else {
              openFile(fileSelected.getAttribute("data-path"))
            }

          } else if (fileSelected.getAttribute("data-type") == "dir") {
            if (fileSelected.getAttribute("data-path").split('.').slice('-1')[0] == "app") {
              try {
                await anura.registerApp(`/fs${fileSelected.getAttribute("data-path")}`.replace('//', '/'))
                anura.notifications.add({
                  title: "Application Installed for Session",
                  description: `Application ${fileSelected.getAttribute("data-path").replace('//', '/')} has been installed temporarily, it will go away on refresh`,
                  timeout: 50000
                })
              } catch (e) {
                anura.notifications.add({
                  title: "Application Install Error",
                  description: `Application had an error installing: ${e}`,
                  timeout: 50000
                })
              }


            } else {
              console.debug("Changing folder to ", fileSelected.getAttribute("data-path"));
              loadPath(fileSelected.getAttribute("data-path"));
            }

          } else {
            console.warn("Unknown filetype ", fileSelected.getAttribute("data-type"), " doing nothing!");
          }
        } else {
          // MULTIPLE FILE SELECTION //

          console.error("raff please implement");
        }
      }

      function setBreadcrumbs(path) {
        path = path.replace(/(\/)\1+/g, '$1')
        var pathSplit = path.split("/");
        console.log(pathSplit);
        pathSplit[0] = "My files";
        var breadcrumbs = document.querySelector(".breadcrumbs");
        breadcrumbs.setAttribute("data-current-path", path);
        breadcrumbs.innerHTML = '';
        if (pathSplit.length == 2 && pathSplit[0] == "My files" && pathSplit[1] == "") {
          var breadcrumb = document.createElement("button");
          breadcrumb.innerText = "My files";
          breadcrumb.addEventListener("click", () => {
            loadPath('/');
          });
          breadcrumbs.appendChild(breadcrumb);
          return;
        }
        for (var i = 0; i < pathSplit.length; i++) {
          console.log(i);
          var breadcrumb = document.createElement("button");
          breadcrumb.innerText = pathSplit[i];
          var index = i;
          breadcrumb.addEventListener("click", () => {
            loadPath('/' + pathSplit.slice(1, index).join('/'));
          });
          breadcrumbs.appendChild(breadcrumb)
          if (pathSplit[i] !== pathSplit[pathSplit.length - 1]) {
            var breadcrumbSpan = document.createElement("span");
            breadcrumbSpan.innerText = ">";
            breadcrumbs.appendChild(breadcrumbSpan);
          }
        }
      }

      document.querySelector("table").addEventListener("click", (e) => {
        if (e.currentTarget === e.target) {
          currentlySelected.forEach((row) => {
            row.classList.remove("selected")
          });
          currentlySelected = [];
        }
      });
      document.addEventListener("contextmenu", (e) => {
        if (e.shiftKey) {
          return;
        }
        e.preventDefault();
        const boundingRect = window.frameElement.getBoundingClientRect()
        // var contextmenu = document.querySelector("#contextMenu");

        // contextmenu.style.left = e.pageX + "px";
        // contextmenu.style.top = e.pageY + "px";
        // const hasSelection = currentlySelected.length > 0;
        // for (const elt of contextmenu.getElementsByClassName("needs-selection")) {
        //     elt.ariaDisabled = !hasSelection;
        //     elt.onclick = hasSelection ? elt.onclick : null;
        // }
        // contextmenu.style.removeProperty("display");
        newcontextmenu.show(e.pageX + boundingRect.x, e.pageY + boundingRect.y)
      });

      document.addEventListener("click", (e) => {
        if (!document.querySelector("#contextMenu").contains(e.target) || !e.target.ariaDisabled) {
          // document.querySelector("#contextMenu").style.setProperty("display", "none");
          newcontextmenu.hide()
        }
      });

      function newFolder(path) {
        if (path === undefined) {
          path = document.querySelector(".breadcrumbs").getAttribute("data-current-path") + '/' + prompt('Folder Name: ')
        }
        fs.mkdir(path)
        reload()
      }

      function reload() {
        loadPath(document.querySelector(".breadcrumbs").getAttribute("data-current-path"))
      }

      function reload() {
        loadPath(document.querySelector(".breadcrumbs").getAttribute("data-current-path"))
      }

      function upload() {

        let fauxput = document.createElement('input') // fauxput - fake input that isn't shown or ever added to page TODO: think of a better name for this variable
        fauxput.type = 'file'
        fauxput.onchange = async (e) => {
          const file = await e.target.files[0]
          const content = await file.arrayBuffer()
          fs.writeFile(`${document.querySelector(".breadcrumbs").getAttribute("data-current-path")}/${file.name}`, Buffer.from(content), function(err) {
            reload();
          })
        }
        fauxput.click()
      }

      function deleteFile() {
        if (currentlySelected.length == 0) {
          alert("BUG: You have no files selected, right clicking does not select files")
        }
        currentlySelected.forEach(async item => {
          await sh.rm(item.getAttribute("data-path"), {
            recursive: true
          }, function(err) {
            if (err) throw err;
            reload()
          })

        })
      }

      function copy() {
        clipboard = currentlySelected
        removeAfterPaste = false
      }

      function cut() {
        clipboard = currentlySelected
        removeAfterPaste = true
      }

      function paste() {
        const path = document.querySelector(".breadcrumbs").getAttribute("data-current-path")
        if (!removeAfterPaste) { // copy
            destination = path;
            clipboard.forEach(item => {
                origin = item.getAttribute("data-path")
                fs.stat(origin, function (err, data) {
                    if (data.isDirectory()) {
                        // Ok so you are about to be in for a ride
                        sh.ls(origin, {
                        recursive: true
                    }, async function(err, entries) {
                        if (err) throw err;
                        let items = []
                        let dirs = []
                        entries.forEach(entry => {
                            function recurse(dirnode, path) {
                            dirnode.contents.forEach(entry => {
                                if (entry.type === "DIRECTORY") {
                                    recurse(entry, path + "/" + entry.name)
                                    dirs.push(path + "/" + entry.name)
                                } else {
                                    items.push(path + "/" + entry.name)
                                }

                            })
                            }
                            if (entry.type === "DIRECTORY") {
                                recurse(entry, origin + '/' + entry.name)
                                dirs.push(origin + '/' + entry.name)
                            } else {
                                items.push("/" + entry.name)
                            }

                        })
                        destItems = []
                        destDirs = []
                        numberToSubBy = origin.length
                        for (item in items) {
                            console.log(items[item])
                            destItems.push(destination + '/' + items[item].slice(numberToSubBy))
                        }
                        for (dir in dirs) {
                            destDirs.push(destination + '/' + dirs[dir].slice(numberToSubBy))
                        }
                        console.log("initials")
                        console.log(items)
                        console.log("destinations")
                        console.log(destItems)
                        console.log('directories to mkdir -p ')
                        console.log(destDirs)
                        for (dir in destDirs) {
                            await new Promise((resolve, reject) =>{
                                sh.mkdirp(destDirs[dir], function (err) {
                                    if (err) {
                                        reject(err);
                                        console.error(err)
                                    }
                                    resolve()
                                })
                            }) 
                        }

                        for (item in items) {
                            fs.readFile(items[item], function(err, data) {
                                fs.writeFile(destItems[item], data)
                            })
                        }
                    });
                    } else {
                        fs.readFile(origin, function (err, data) {
                            if (err) throw err;
                            fs.writeFile(`${path}/${origin.split("/").slice("-1")[0]}`)
                        })
                    }
                    reload()
                })
            })
        }
        if (removeAfterPaste) { // cut
          clipboard.forEach(item => {
            itemName = item.getAttribute("data-path")
            fs.rename(itemName, `${path}/${itemName.split("/").slice("-1")[0]}`, function(err) {
              if (err) throw err;
              reload()
            });
          })
        }
      }

      function rename() {
        const path = document.querySelector(".breadcrumbs").getAttribute("data-current-path")
        if (currentlySelected.length == 0) {
          alert("BUG: You have no files selected, right clicking does not select files")
          return;
        }
        if (currentlySelected.length > 1) {
          alert("Renaming only works with one file")
          return;
        }
        fs.rename(currentlySelected[0].getAttribute("data-path"), `${path}/${prompt("filename:")}`, function(err) {
          if (err) throw err;
          reload()
        })
      }
      loadPath('/');
    </script>
    <div style="display: none;" id="contextMenu">
      <button>Get info</button>
      <button>Pin to shelf</button>
      <button onclick="reload()">Refresh</button>
      <hr>
      </hr>
      <button class="needs-selection" onclick="cut()">Cut</button>
      <button class="needs-selection" onclick="copy()">Copy</button>
      <button onclick="paste()">Paste</button>
      <button class="needs-selection" onclick="deleteFile()">Delete</button>
      <button onclick="upload()">Upload from PC</button>
      <hr>
      </hr>
      <button onclick="newFolder()">New folder</button>
    </div>
  </body>

</html>